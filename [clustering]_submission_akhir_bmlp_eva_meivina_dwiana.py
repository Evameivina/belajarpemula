# -*- coding: utf-8 -*-
"""[Clustering]_Submission_Akhir_BMLP_Eva Meivina Dwiana.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k2g2m_vL_vetgoY5ChB6D_TWW3sgK5VA

# **1. Perkenalan Dataset**

*Eva Meivina Dwiana_mc009d5x0328*

Tahap pertama, Anda harus mencari dan menggunakan dataset **tanpa label** dengan ketentuan sebagai berikut:

1. **Sumber Dataset**:  
   Dataset dapat diperoleh dari berbagai sumber, seperti public repositories (*Kaggle*, *UCI ML Repository*, *Open Data*) atau data primer yang Anda kumpulkan sendiri.
   
2. **Ketentuan Dataset**:
   - **Tanpa label**: Dataset tidak boleh memiliki label atau kelas.
   - **Jumlah Baris**: Minimal 1000 baris untuk memastikan dataset cukup besar untuk analisis yang bermakna.
   - **Tipe Data**: Harus mengandung data **kategorikal** dan **numerikal**.
     - *Kategorikal*: Misalnya jenis kelamin, kategori produk.
     - *Numerikal*: Misalnya usia, pendapatan, harga.

3. **Pembatasan**:  
   Dataset yang sudah digunakan dalam latihan clustering (seperti customer segmentation) tidak boleh digunakan.

# **2. Import Library**

Pada tahap ini, Anda perlu mengimpor beberapa pustaka (library) Python yang dibutuhkan untuk analisis data dan pembangunan model machine learning.
"""

import seaborn as sns
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.preprocessing import StandardScaler
from sklearn.feature_selection import VarianceThreshold
from sklearn.decomposition import PCA

"""# **3. Memuat Dataset**

Pada tahap ini, Anda perlu memuat dataset ke dalam notebook. Jika dataset dalam format CSV, Anda bisa menggunakan pustaka pandas untuk membacanya. Pastikan untuk mengecek beberapa baris awal dataset untuk memahami strukturnya dan memastikan data telah dimuat dengan benar.

Jika dataset berada di Google Drive, pastikan Anda menghubungkan Google Drive ke Colab terlebih dahulu. Setelah dataset berhasil dimuat, langkah berikutnya adalah memeriksa kesesuaian data dan siap untuk dianalisis lebih lanjut.
"""

bank_data_df = pd.read_csv("https://raw.githubusercontent.com/Evameivina/proyekbelajarpemula/refs/heads/main/bank_data.csv")
bank_data_df.head()

"""# **4. Exploratory Data Analysis (EDA)**

Pada tahap ini, Anda akan melakukan **Exploratory Data Analysis (EDA)** untuk memahami karakteristik dataset. EDA bertujuan untuk:

1. **Memahami Struktur Data**
   - Tinjau jumlah baris dan kolom dalam dataset.  
   - Tinjau jenis data di setiap kolom (numerikal atau kategorikal).

2. **Menangani Data yang Hilang**  
   - Identifikasi dan analisis data yang hilang (*missing values*). Tentukan langkah-langkah yang diperlukan untuk menangani data yang hilang, seperti pengisian atau penghapusan data tersebut.

3. **Analisis Distribusi dan Korelasi**  
   - Analisis distribusi variabel numerik dengan statistik deskriptif dan visualisasi seperti histogram atau boxplot.  
   - Periksa hubungan antara variabel menggunakan matriks korelasi atau scatter plot.

4. **Visualisasi Data**  
   - Buat visualisasi dasar seperti grafik distribusi dan diagram batang untuk variabel kategorikal.  
   - Gunakan heatmap atau pairplot untuk menganalisis korelasi antar variabel.

Tujuan dari EDA adalah untuk memperoleh wawasan awal yang mendalam mengenai data dan menentukan langkah selanjutnya dalam analisis atau pemodelan.
"""

print("Dimensi data (jumlah baris & kolom):", bank_data_df.shape)
bank_data_df.info()

jumlah_duplikat = bank_data_df.duplicated().sum()
print("Jumlah baris duplikat:", jumlah_duplikat)

bank_data_df.isnull().sum()

bank_data_df.describe()

fitur_angka = bank_data_df.select_dtypes('number').columns

color = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b']

plt.figure(figsize=(10, 7))
for idx, kolom in enumerate(fitur_angka):
    plt.subplot(2, 3, idx + 1)
    sns.histplot(bank_data_df[kolom], bins=15, kde=True, color=color[idx % len(color)])
    plt.title(f"{kolom}", fontsize=10)

plt.suptitle("Distribution of Numerical Data", fontsize=12, y=1.05)
plt.tight_layout()
plt.show()

num_cols_only = bank_data_df.select_dtypes('number')

corr_result = num_cols_only.corr(numeric_only=True)

fig, ax = plt.subplots(figsize=(12, 6))
heat = sns.heatmap(
    corr_result,
    ax=ax,
    annot=True,
    fmt=".2f",
    cmap='YlGnBu',
    square=True,
    cbar_kws={"shrink": .75}
)
ax.set_title("Numerical Feature Correlations", fontsize=12)
plt.tight_layout()
plt.show()

"""# **5. Data Preprocessing**

Pada tahap ini, data preprocessing adalah langkah penting untuk memastikan kualitas data sebelum digunakan dalam model machine learning. Data mentah sering kali mengandung nilai kosong, duplikasi, atau rentang nilai yang tidak konsisten, yang dapat memengaruhi kinerja model. Oleh karena itu, proses ini bertujuan untuk membersihkan dan mempersiapkan data agar analisis berjalan optimal.

Berikut adalah tahapan-tahapan yang bisa dilakukan, tetapi **tidak terbatas** pada:
1. Menghapus atau Menangani Data Kosong (Missing Values)
2. Menghapus Data Duplikat
3. Normalisasi atau Standarisasi Fitur
4. Deteksi dan Penanganan Outlier
5. Encoding Data Kategorikal
6. Binning (Pengelompokan Data)

Cukup sesuaikan dengan karakteristik data yang kamu gunakan yah.
"""

df_proc = bank_data_df.copy()

columns_to_exclude = {
    'TransactionID', 'AccountID', 'TransactionDate', 'Location',
    'DeviceID', 'IP Address', 'MerchantID', 'Channel',
    'PreviousTransactionDate', 'TransactionDuration', 'TransactionType'
}
existing_cols = list(set(columns_to_exclude).intersection(bank_data_df.columns))
cleaned_df = bank_data_df.drop(existing_cols, axis=1)

if 'CustomerOccupation' in cleaned_df.columns:
    occ_vals = cleaned_df['CustomerOccupation']
    if len(occ_vals.unique()) > 5:
        encoded_vals = occ_vals.map(occ_vals.value_counts())
        cleaned_df['CustomerOccupation'] = encoded_vals
    else:
        encoded_df = pd.get_dummies(cleaned_df['CustomerOccupation'], prefix='Occ')
        cleaned_df = pd.concat([cleaned_df.drop(columns='CustomerOccupation'), encoded_df], axis=1)

for num_col in cleaned_df.select_dtypes(include='number'):
    stats = cleaned_df[num_col].describe()
    iqr_range = stats['75%'] - stats['25%']
    out_low = stats['25%'] - 1.5 * iqr_range
    out_high = stats['75%'] + 1.5 * iqr_range
    cleaned_df[num_col] = cleaned_df[num_col].apply(lambda x: out_low if x < out_low else (out_high if x > out_high else x))

cleaned_df.head(10)

"""# **6. Pembangunan Model Clustering**

## **a. Pembangunan Model Clustering**

Pada tahap ini, Anda membangun model clustering dengan memilih algoritma yang sesuai untuk mengelompokkan data berdasarkan kesamaan. Berikut adalah **rekomendasi** tahapannya.
1. Pilih algoritma clustering yang sesuai.
2. Latih model dengan data menggunakan algoritma tersebut.
"""

sse_scores = []
jumlah_cluster_dicoba = range(2, 11)

numerical_features = bank_data_df.select_dtypes(include=np.number).columns
bank_data_num = bank_data_df[numerical_features]

scaler = StandardScaler()
bank_data_df_scaled = scaler.fit_transform(bank_data_num)

for jumlah in jumlah_cluster_dicoba:
    kmeans = KMeans(n_clusters=jumlah, random_state=42, n_init=10)
    kmeans.fit(bank_data_df_scaled)
    sse_scores.append(kmeans.inertia_)

plt.figure(figsize=(9, 5))
plt.plot(jumlah_cluster_dicoba, sse_scores, color='royalblue', marker='^', linewidth=2)
plt.title("Grafik Elbow untuk Menentukan Jumlah Klaster")
plt.xlabel("Jumlah Klaster (k)")
plt.ylabel("Inertia (SSE)")
plt.grid(True)
plt.show()

"""## **b. Evaluasi Model Clustering**

Untuk menentukan jumlah cluster yang optimal dalam model clustering, Anda dapat menggunakan metode Elbow atau Silhouette Score.

Metode ini membantu kita menemukan jumlah cluster yang memberikan pemisahan terbaik antar kelompok data, sehingga model yang dibangun dapat lebih efektif. Berikut adalah **rekomendasi** tahapannya.
1. Gunakan Silhouette Score dan Elbow Method untuk menentukan jumlah cluster optimal.
2. Hitung Silhouette Score sebagai ukuran kualitas cluster.
"""

skor_silhouette = {
    k: silhouette_score(bank_data_df_scaled,
                        KMeans(n_clusters=k, random_state=42, n_init=10).fit_predict(bank_data_df_scaled))
    for k in range(2, 11)
}

for k, skor in skor_silhouette.items():
    print(f"Skor Silhouette untuk {k} klaster: {skor:.4f}")

optimal_klaster = max(skor_silhouette, key=skor_silhouette.get)
print(f"Jumlah klaster terbaik: {optimal_klaster}")

model_final = KMeans(n_clusters=optimal_klaster, random_state=42, n_init=10)
bank_data_df['Cluster'] = model_final.fit_predict(bank_data_df_scaled)

bank_data_df.head()

"""## **c. Feature Selection (Opsional)**"""

numerical_columns = ['TransactionAmount', 'CustomerAge']
scaler = StandardScaler()
df_scaled = scaler.fit_transform(bank_data_df[numerical_columns])

selector = VarianceThreshold(threshold=0.01)
df_selected = selector.fit_transform(df_scaled)

print(f"Jumlah fitur sebelum seleksi: {df_scaled.shape[1]}")
print(f"Jumlah fitur setelah seleksi: {df_selected.shape[1]}")

pca = PCA(n_components=2)
df_pca = pca.fit_transform(df_scaled)

silhouette_vals = {}
silhouette_pca = {}

for k in range(2, 11):
    model = KMeans(n_clusters=k, random_state=42, n_init=10)
    labels = model.fit_predict(bank_data_num)

    score = silhouette_score(bank_data_num, labels)
    silhouette_vals[k] = score
    print(f"Silhouette Score untuk {k} cluster: {score:.4f}")

    model_pca = KMeans(n_clusters=k, random_state=42, n_init=10)
    labels_pca = model_pca.fit_predict(df_pca)
    score_pca = silhouette_score(df_pca, labels_pca)
    silhouette_pca[k] = score_pca
    print(f"Silhouette Score untuk {k} cluster setelah PCA: {score_pca:.4f}")


optimal_k_pca = max(silhouette_pca, key=silhouette_pca.get)
print(f"Jumlah cluster optimal setelah Feature Selection: {optimal_k_pca}")

df_scaled = pd.DataFrame(df_scaled, columns=numerical_columns, index=bank_data_df.index)

final_model_pca = KMeans(n_clusters=optimal_k_pca, random_state=42, n_init=10)
df_scaled['Cluster_PCA'] = final_model_pca.fit_predict(df_pca)

plt.plot(silhouette_vals.keys(), silhouette_vals.values(), marker='o', label="Sebelum Feature Selection")
plt.plot(silhouette_pca.keys(), silhouette_pca.values(), marker='s', linestyle='dashed', label="Sesudah Feature Selection")

"""Silakan lakukan feature selection jika Anda membutuhkan optimasi model clustering. Jika Anda menerapkan proses ini, silakan lakukan pemodelan dan evaluasi kembali menggunakan kolom-kolom hasil feature selection. Terakhir, bandingkan hasil performa model sebelum dan sesudah menerapkan feature selection.

## **d. Visualisasi Hasil Clustering**

Setelah model clustering dilatih dan jumlah cluster optimal ditentukan, langkah selanjutnya adalah menampilkan hasil clustering melalui visualisasi.

Berikut adalah **rekomendasi** tahapannya.
1. Tampilkan hasil clustering dalam bentuk visualisasi, seperti grafik scatter plot atau 2D PCA projection.
"""

import seaborn as sns
import matplotlib.pyplot as plt

sns.set_theme(style="whitegrid")
plt.figure(figsize=(8, 6))

sns.scatterplot(
    data=bank_data_df,
    x='CustomerAge',
    y='AccountBalance',
    hue='Cluster',
    palette='plasma',
    alpha=0.7,
    s=60
)

plt.title('Klaster Usia vs Saldo')
plt.xlabel('Usia (CustomerAge)')
plt.ylabel('Saldo (AccountBalance)')
plt.legend(title='Klaster', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""## **e. Analisis dan Interpretasi Hasil Cluster**

### Interpretasi Target

**Tutorial: Melakukan Inverse Transform pada Data Target Setelah Clustering**

Setelah melakukan clustering dengan model **KMeans**, kita perlu mengembalikan data yang telah diubah (normalisasi, standarisasi, atau label encoding) ke bentuk aslinya. Berikut adalah langkah-langkahnya.

---

**1. Tambahkan Hasil Label Cluster ke DataFrame**
Setelah mendapatkan hasil clustering, kita tambahkan label cluster ke dalam DataFrame yang telah dinormalisasi.

```python
df_normalized['Cluster'] = model_kmeans.labels_
```

Lakukan Inverse Transform pada feature yang sudah dilakukan Labelisasi dan Standararisasi. Berikut code untuk melakukannya:
label_encoder.inverse_transform(X_Selected[['Fitur']])

Lalu masukkan ke dalam kolom dataset asli atau membuat dataframe baru
```python
df_normalized['Fitur'] = label_encoder.inverse_transform(df_normalized[['Fitur']])
```
Masukkan Data yang Sudah Di-Inverse ke dalam Dataset Asli atau Buat DataFrame Baru
```python
df_original['Fitur'] = df_normalized['Fitur']
```
"""

encoded_columns = [col for col in bank_data_df.columns if col.startswith('Occ_')]

if encoded_columns:

    bank_data_df['CustomerOccupation_Original'] = (
        bank_data_df[encoded_columns]
        .idxmax(axis=1)
        .str.replace("Occ_", "")
    )

    bank_data_df.drop(columns=encoded_columns, inplace=True)

    bank_data_df.rename(
        columns={'CustomerOccupation_Original': 'CustomerOccupation'},
        inplace=True
    )

selected_columns = [
    'TransactionAmount',
    'CustomerAge',
    'CustomerOccupation',
    'LoginAttempts',
    'AccountBalance',
    'Cluster'
]

print("Contoh data hasil inverse transform untuk interpretasi cluster:")
bank_data_df[selected_columns].head(10)

"""### Inverse Data Jika Melakukan Normalisasi/Standardisasi

Inverse Transform untuk Data yang Distandarisasi
Jika data numerik telah dinormalisasi menggunakan StandardScaler atau MinMaxScaler, kita bisa mengembalikannya ke skala asli:
```python
df_normalized[['Fitur_Numerik']] = scaler.inverse_transform(df_normalized[['Fitur_Numerik']])
```
"""

# Saya tidak menerapkan metode normalisasi atau standardisasi pada dataset ini

"""Setelah melakukan clustering, langkah selanjutnya adalah menganalisis karakteristik dari masing-masing cluster berdasarkan fitur yang tersedia.

Berikut adalah **rekomendasi** tahapannya.
1. Analisis karakteristik tiap cluster berdasarkan fitur yang tersedia (misalnya, distribusi nilai dalam cluster).
2. Berikan interpretasi: Apakah hasil clustering sesuai dengan ekspektasi dan logika bisnis? Apakah ada pola tertentu yang bisa dimanfaatkan?
"""

clusters = bank_data_df['Cluster'].unique()

for c in sorted(clusters):
    data_per_cluster = bank_data_df[bank_data_df['Cluster'] == c]
    print(f"\n>>> Karakteristik Cluster {c}")
    summary = data_per_cluster[['TransactionAmount', 'CustomerAge', 'TransactionDuration', 'AccountBalance']].describe()
    print(summary)

    avg_amount = summary.loc['mean', 'TransactionAmount']
    avg_age = summary.loc['mean', 'CustomerAge']
    avg_duration = summary.loc['mean', 'TransactionDuration']
    avg_balance = summary.loc['mean', 'AccountBalance']

    print(f"Interpretasi Cluster {c}:")
    print(f"- Rata-rata transaksi: ${avg_amount:.2f}")
    print(f"- Rata-rata usia pelanggan: {avg_age:.1f} tahun")
    print(f"- Rata-rata durasi transaksi: {avg_duration:.1f} detik")
    print(f"- Rata-rata saldo: ${avg_balance:.2f}")

    if avg_amount > 1000:
        print("- Cluster ini cenderung berisi transaksi besar.")
    if avg_balance > 7000:
        print("- Pelanggan dalam cluster ini memiliki saldo tinggi.")
    if avg_age < 30:
        print("- Cluster ini didominasi oleh pelanggan muda.")

"""#### Berikut adalah analisis karakteristik untuk setiap cluster yang dihasilkan dari model KMeans :

**Cluster 0**
* **Rata-rata Jumlah Transaksi ($):** 199.63

* **Rata-rata Usia Pelanggan (tahun):** 62.32

* **Rata-rata Durasi Transaksi (detik):** 91.78

* **Rata-rata Saldo Akun ($)**: 4,592.40

* **Analisis:**
Cluster ini terdiri dari pelanggan berusia matang dengan saldo cukup stabil dan transaksi sedang. Mereka berhati-hati dalam berbelanja dan tidak terburu-buru. Produk yang cocok adalah tabungan jangka panjang atau deposito.

**Cluster 1**
* **Rata-rata Jumlah Transaksi ($):** 276.32

* **Rata-rata Usia Pelanggan (tahun):** 44.54

* **Rata-rata Durasi Transaksi (detik):** 131.88

* **Rata-rata Saldo Akun ($):** 1,582.5,461.64

* **Analisis:**
Pelanggan di cluster ini relatif lebih muda dan cukup aktif bertransaksi dengan saldo menengah. Mereka potensial untuk program loyalitas, promo menarik, atau penawaran cashback dan diskon khusus.

**Cluster 2**
* **Rata-rata Jumlah Transaksi ($):** 234.87

* **Rata-rata Usia Pelanggan (tahun):** 47.35

* **Rata-rata Durasi Transaksi (detik):** 234.93

* **Rata-rata Saldo Akun ($):** 4,830.76

* **Analisis:**
Cluster ini memiliki durasi transaksi paling panjang, menunjukkan pelanggan yang teliti dan mempertimbangkan keputusan belanja. Strategi yang cocok adalah edukasi produk atau rekomendasi lebih mendetail.

**Cluster 3**
* **Rata-rata Jumlah Transaksi ($):** 939.91

* **Rata-rata Usia Pelanggan (tahun):** 46.25

* **Rata-rata Durasi Transaksi (detik):** 113.68

* **Rata-rata Saldo Akun ($):** 4,987.69

* **Analisis:**
Pelanggan di cluster ini memiliki transaksi tinggi dengan saldo menengah hingga tinggi. Mereka cocok untuk produk premium atau eksklusif, seperti paket investasi atau layanan keuangan khusus.

**Cluster 4**
* **Rata-rata Jumlah Transaksi ($):** 236.42

* **Rata-rata Usia Pelanggan (tahun):** 25.84

* **Rata-rata Durasi Transaksi (detik):** 97.20

* **Rata-rata Saldo Akun ($):** 1,612.88

* **Analisis:**
Cluster ini didominasi pelanggan muda dengan saldo rendah dan transaksi menengah. Strategi pemasaran yang cocok adalah promo ringan, cicilan, atau produk lifestyle yang menarik generasi muda.


**Cluster 5**
* **Rata-rata Jumlah Transaksi ($):** 224.02

* **Rata-rata Usia Pelanggan (tahun):** 44.77

* **Rata-rata Durasi Transaksi (detik):** 100.77

* **Rata-rata Saldo Akun ($):** 10,265.91

* **Analisis:**
Pelanggan di cluster ini memiliki saldo sangat tinggi dengan transaksi menengah. Mereka cocok untuk produk premium, investasi besar, atau layanan keuangan eksklusif.

# **7. Mengeksport Data**

Simpan hasilnya ke dalam file CSV.
"""

bank_data_df.to_csv("dataset_inisiasi.csv", index=False)
print("Hasil clustering telah berhasil disimpan dalam file dataset_inisiasi.csv")

